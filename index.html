<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MVP - Mapa de Calor de São Paulo</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { font-family: sans-serif; margin: 0; }
        #map { height: 100vh; }
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
            .legend {
                position: absolute;
                bottom: 10px;
                left: 10px;
                z-index: 1000;
                background: white;
                padding: 8px;
                border-radius: 5px;
                border: 1px solid #ccc;
                line-height: 1.2;
                font-size: 12px;
            }
            .legend-item { display: flex; align-items: center; margin: 2px 0; }
            .legend-color { width: 16px; height: 12px; margin-right: 6px; border: 1px solid #999; }
            .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
            .muted { color: #666; font-size: 12px; }
    </style>
</head>
<body>

    <div id="map"></div>

    <div class="info-panel">
            <h3>Visualizar Métrica</h3>
            <div class="row">
                <select id="metric-selector">
                    <option value="vl_renda" selected>Renda mediana per capita</option>
                    <option value="distancia_metro_m">Distância do Metrô (m)</option>
                </select>
                <label for="class-count">Cortes:</label>
                <input id="class-count" type="range" min="5" max="9" value="7" />
                <span id="class-count-val" class="muted">7</span>
            </div>
            <hr/>
            <h4>Renda × Distância</h4>
            <div class="muted">Correlação (Pearson/Spearman) na área visível</div>
            <div>
                r=<b id="corr-val">—</b> · ρ=<b id="corr-spear">—</b>
                (n=<span id="sample-n">0</span>)
            </div>
            <div class="muted">Intermunicipal: r_b=<b id="corr-between">—</b> · ρ_b=<b id="corr-spear-between">—</b></div>
            <div class="row">
                <label class="muted">renda:</label>
                <select id="renda-metric">
                    <option value="vl_renda" selected>municipal</option>
                    <option value="vl_renda_setor">setorial</option>
                </select>
                <label class="muted">distância:</label>
                <select id="dist-metric">
                    <option value="distancia_metro_m" selected>todas as linhas</option>
                </select>
            </div>
            <canvas id="scatter" width="300" height="180"></canvas>
            <div class="row" style="margin-top:6px;">
                <span class="muted">Médias por faixas de distância (bins)</span>
                <select id="bin-mode">
                    <option value="width" selected>largura igual</option>
                    <option value="quantile">quantis</option>
                </select>
                <label class="muted" style="margin-left:4px;">
                    <input type="checkbox" id="toggle-demeaned" /> intra-município
                </label>
            </div>
            <canvas id="bins" width="300" height="160"></canvas>
        </div>
        <div id="legend" class="legend"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script>
        // Coordenadas de São Paulo
        const map = L.map('map').setView([-23.5505, -46.6333], 11);
    let geoJsonLayer;
    let stationsLayer;
            let scatterChart;
            let binsChart;
            let currentBreaks = [];
            let currentPalette = [];
            let pointsLayer;

        // Adiciona o mapa base
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

    // Paletas
            const palettes = {
                vl_renda: ['#FFEDA0','#FED976','#FEB24C','#FD8D3C','#FC4E2A','#E31A1C','#BD0026','#800026'], // low->high
                distancia_metro_m: ['#92c5de','#d1e5f0','#fddbc7','#f4a582','#d6604d','#b2182b','#6e0118','#3a000c']
            };

            function getColorFromBreaks(v, breaks, palette){
                if (v == null || isNaN(v)) return '#ccc';
                for (let i=0; i<breaks.length-1; i++){
                    if (v >= breaks[i] && v <= breaks[i+1]) return palette[i];
                }
                // fallback
                return palette[palette.length-1];
            }

            // Quebras por quantis
            function quantile(sorted, q){
                const pos = (sorted.length - 1) * q;
                const base = Math.floor(pos);
                const rest = pos - base;
                if (sorted[base + 1] !== undefined) {
                    return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
                }
                return sorted[base];
            }

            function computeQuantileBreaks(values, classes){
                const arr = values.filter(v => typeof v === 'number' && isFinite(v)).sort((a,b)=>a-b);
                if (arr.length === 0) return [];
                const brks = [];
                for (let i=0;i<=classes;i++){
                    brks.push(quantile(arr, i/classes));
                }
                return brks;
            }

            function formatBreak(a){
                return a.map(v => (Math.abs(v) >= 1000 ? v.toFixed(0) : v.toFixed(2)));
            }

            function updateLegend(metric, breaks, palette){
                const el = document.getElementById('legend');
                if (!breaks || breaks.length < 2){ el.innerHTML = '<i>Sem dados</i>'; return; }
                const fmt = formatBreak(breaks);
                let html = `<b>${metric}</b>`;
                html += `<div class="muted">Min: ${fmt[0]} • Max: ${fmt[fmt.length-1]} • Quebra: quantis</div>`;
                for (let i=0; i<palette.length; i++){
                    html += `<div class="legend-item"><span class="legend-color" style="background:${palette[i]}"></span>`+
                            `<span>${fmt[i]} – ${fmt[i+1]}</span></div>`;
                }
                el.innerHTML = html;
            }

        // Função de estilo para a camada GeoJSON
        function styleFeature(feature) {
            const metric = document.getElementById('metric-selector').value;
                const val = feature.properties[metric];
                const color = getColorFromBreaks(val, currentBreaks, currentPalette);
                return {
                    fillColor: color,
                weight: 0.5,
                opacity: 1,
                color: 'white',
                fillOpacity: 0.7
            };
        }

        // Função para adicionar interatividade (popup)
        function onEachFeature(feature, layer) {
            const metric = document.getElementById('metric-selector').value;
            const value = feature.properties[metric];
            if (value) {
                layer.bindPopup(`<b>ID do Setor:</b> ${feature.properties.id}<br><b>${metric}:</b> ${value.toFixed(2)}`);
            }
        }

        // Função principal que busca os dados e atualiza o mapa
    async function updateMap() {
            const selectedMetric = document.getElementById('metric-selector').value;
            const API_BASE = 'http://localhost:8000';
            const b = map.getBounds();
            const bbox = [b.getWest(), b.getSouth(), b.getEast(), b.getNorth()].join(',');
            // snap agrega pontos em uma grade para aliviar renderização em zoom amplo
            const snap = map.getZoom() <= 11 ? '0.002' : (map.getZoom() <= 12 ? '0.001' : '');
            const params = new URLSearchParams({ metric: selectedMetric, bbox, limit: '50000' });
            if (snap) params.set('snap', snap);
            const apiUrl = `${API_BASE}/points?${params.toString()}`;
            
            // Remove a camada antiga se ela existir
            if (geoJsonLayer) { map.removeLayer(geoJsonLayer); }
            if (pointsLayer) { map.removeLayer(pointsLayer); }

            try {
                const response = await fetch(apiUrl);
                const data = await response.json();

                // calcular quebras com base nos dados carregados
                const classCount = parseInt(document.getElementById('class-count').value, 10);
                const vals = data.features.map(f => f.properties[selectedMetric]).filter(v => v != null);
                const classes = Math.min(classCount, palettes[selectedMetric].length);
                currentBreaks = computeQuantileBreaks(vals, classes);
                currentPalette = palettes[selectedMetric].slice(0, Math.max(1, currentBreaks.length - 1));

                // pontos em canvas para performance
                pointsLayer = L.geoJSON(data, {
                    pointToLayer: (feature, latlng) => {
                        const val = feature.properties[selectedMetric];
                        const color = getColorFromBreaks(val, currentBreaks, currentPalette);
                        return L.circleMarker(latlng, {
                            radius: 3,
                            color: '#000',
                            weight: 0.2,
                            fillColor: color,
                            fillOpacity: 0.85,
                            pane: 'markerPane'
                        });
                    },
                    onEachFeature: (feature, layer) => {
                        const val = feature.properties[selectedMetric];
                        const isNum = typeof val === 'number' && isFinite(val);
                        const valStr = val == null ? '—' : (isNum ? val.toFixed(2) : String(val));
                        layer.bindPopup(`<b>ID do Setor:</b> ${feature.properties.id}<br><b>${selectedMetric}:</b> ${valStr}`);
                    }
                }, {renderer: L.canvas()}).addTo(map);

                    updateLegend(selectedMetric, currentBreaks, currentPalette);
            } catch (error) {
                console.error('Erro ao carregar dados do mapa:', error);
                alert('Não foi possível carregar os dados. Verifique o console.');
            }

            // estações
            try {
                const API_BASE = 'http://localhost:8000';
                const b = map.getBounds();
                const bbox = [b.getWest(), b.getSouth(), b.getEast(), b.getNorth()].join(',');
                const url = `${API_BASE}/stations?bbox=${bbox}&limit=3000`;
                const r = await fetch(url);
                const gj = await r.json();
                if (stationsLayer) { map.removeLayer(stationsLayer); }
                stationsLayer = L.geoJSON(gj, {
                    pointToLayer: (feature, latlng) => L.circleMarker(latlng, {
                        radius: 3,
                        color: '#111',
                        weight: 1,
                        fillColor: '#2ca02c',
                        fillOpacity: 0.9
                    }),
                    onEachFeature: (feature, layer) => {
                        const props = feature.properties || {};
                        const name = props.name || props.NOME || 'Estação';
                        layer.bindPopup(`<b>${name}</b>`);
                    }
                }).addTo(map);
            } catch(e) {
                console.error('Erro ao carregar estações', e);
            }
        }

            async function updateStats(){
                const API_BASE = 'http://localhost:8000';
                const b = map.getBounds();
                const bbox = [b.getWest(), b.getSouth(), b.getEast(), b.getNorth()].join(',');
                const binModeSel = document.getElementById('bin-mode');
                const demeanToggle = document.getElementById('toggle-demeaned');
                const rendaSel = document.getElementById('renda-metric');
                const distSel = document.getElementById('dist-metric');
                const url = `${API_BASE}/stats?bbox=${bbox}&sample_limit=800&bins=8&bin_mode=${binModeSel.value}&renda_metric=${rendaSel.value}&dist_metric=${distSel.value}`;
                try{
                    const r = await fetch(url);
                    const js = await r.json();
                    document.getElementById('corr-val').innerText = (js.r == null ? '—' : js.r.toFixed(3));
                    document.getElementById('corr-spear').innerText = (js.r_s == null ? '—' : js.r_s.toFixed(3));
                    document.getElementById('sample-n').innerText = js.count || 0;
                    document.getElementById('corr-between').innerText = (js.r_between == null ? '—' : js.r_between.toFixed(3));
                    document.getElementById('corr-spear-between').innerText = (js.r_s_between == null ? '—' : js.r_s_between.toFixed(3));
                    const pts = (js.pairs || []).map(([renda, dist]) => ({x: dist, y: renda}));
                    const ctx = document.getElementById('scatter');
                    if (scatterChart) scatterChart.destroy();
                    scatterChart = new Chart(ctx, {
                        type: 'scatter',
                        data: { datasets: [{ label: 'Renda x Distância', data: pts, pointRadius: 1.8, backgroundColor: '#1f77b4' }] },
                        options: {
                            responsive: false,
                            scales: {
                                x: { title: { display: true, text: 'Distância ao metrô (m)' } },
                                y: { title: { display: true, text: 'Renda (R$)' } }
                            },
                            plugins: { legend: { display: false } }
                        }
                    });

                    // Gráfico de médias por bins de distância
                    const bins = demeanToggle.checked ? (js.bins_demeaned || []) : (js.bins || []);
                    const labels = bins.map(b => `${Math.round(b.min || 0)}–${Math.round(b.max || 0)}m`);
                    const rendaAvg = bins.map(b => b.renda_avg || null);
                    const ctx2 = document.getElementById('bins');
                    if (binsChart) binsChart.destroy();
                    binsChart = new Chart(ctx2, {
                        type: 'line',
                        data: {
                            labels,
                            datasets: [{
                                label: 'Renda média',
                                data: rendaAvg,
                                borderColor: '#d62728',
                                backgroundColor: 'rgba(214,39,40,0.2)',
                                pointRadius: 2,
                                fill: true,
                                tension: 0.15
                            }]
                        },
                        options: {
                            responsive: false,
                            scales: {
                                x: { title: { display: true, text: 'Faixas de distância (m)' } },
                                y: { title: { display: true, text: 'Renda média (R$)' } }
                            },
                            plugins: { legend: { display: false } }
                        }
                    });
                }catch(e){
                    console.error('Erro ao carregar estatísticas', e);
                }
            }

        // Event listener para o seletor de métrica
    document.getElementById('metric-selector').addEventListener('change', () => { updateMap(); updateStats(); });
    const classSlider = document.getElementById('class-count');
    const classVal = document.getElementById('class-count-val');
    classSlider.addEventListener('input', () => { classVal.innerText = classSlider.value; });
    classSlider.addEventListener('change', () => { updateMap(); });
    map.on('moveend', () => { updateMap(); updateStats(); });
    map.on('zoomend', () => { updateMap(); });
    document.getElementById('bin-mode').addEventListener('change', updateStats);
    document.getElementById('toggle-demeaned').addEventListener('change', updateStats);
    document.getElementById('renda-metric').addEventListener('change', updateStats);
    document.getElementById('dist-metric').addEventListener('change', updateStats);

        // Carga inicial do mapa
    updateMap();
    // Popular seletor de distâncias dinamicamente a partir das métricas
        (async () => {
        try{
            const API_BASE = 'http://localhost:8000';
            const res = await fetch(`${API_BASE}/metrics`);
            const js = await res.json();
            const distSel = document.getElementById('dist-metric');
            const metrics = (js.metrics || []).map(m => m.metric);
                        const distCols = metrics.filter(m => m.startsWith('distancia_metro_'));
                        // preservar escolha atual (se houver)
                        const prev = distSel.value;
                        // limpar
                        distSel.innerHTML = '';
                        // adicionar opção amigável "todas as linhas"
                        const optAll = document.createElement('option');
                        optAll.value = 'distancia_metro_m';
                        optAll.textContent = 'todas as linhas';
                        distSel.appendChild(optAll);
                        // adicionar opções por linha (excluir *_m)
                        const pretty = (s) => {
                                const name = s.replace('distancia_metro_','');
                                if (name === 'm') return 'todas as linhas';
                                return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
                        };
                        distCols
                            .filter(m => m !== 'distancia_metro_m')
                            .sort()
                            .forEach(m => {
                                const opt = document.createElement('option');
                                opt.value = m;
                                opt.textContent = pretty(m);
                                distSel.appendChild(opt);
                            });
                        // selecionar anterior se ainda existir, senão padrão 'todas as linhas'
                        if ([...distSel.options].some(o => o.value === prev)) {
                                distSel.value = prev;
                        } else {
                                distSel.value = 'distancia_metro_m';
                        }
        }catch(e){ console.warn('Falha ao ler métricas', e); }
        updateStats();
    })();

    // Botões para centralizar por linha
    (async () => {
        try{
            const API_BASE = 'http://localhost:8000';
            const r = await fetch(`${API_BASE}/lines`);
            const js = await r.json();
            const container = document.querySelector('.info-panel');
            const wrap = document.createElement('div');
            wrap.className = 'row';
            const label = document.createElement('span');
            label.className = 'muted';
            label.textContent = 'Centralizar linha:';
            wrap.appendChild(label);
            for (const ln of (js.lines || [])){
                const btn = document.createElement('button');
                btn.textContent = ln.toLowerCase();
                btn.style.margin = '2px';
                btn.onclick = async () => {
                    const q = await fetch(`${API_BASE}/line_extent?linha=${encodeURIComponent(ln)}`);
                    const resp = await q.json();
                    if (resp && resp.center){
                        map.setView(resp.center, 13);
                    }
                };
                wrap.appendChild(btn);
            }
            container.appendChild(wrap);
        }catch(e){ console.warn('Falha ao carregar linhas', e); }
    })();
    </script>
</body>
</html>